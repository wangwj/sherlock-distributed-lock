{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sherlock Distributed Lock","text":"<p>Sherlock is a distributed lock library for JVM projects. It exposes both synchronous and reactive API and uses database connectors to store locks. It was created as a simple solution to manage distributed locks among multiple microservices.</p> <p>By default, locks are acquired for a specific duration. Thanks to this approach when lock owning instance unexpectedly goes down, lock is automatically released after expiration.</p> <p>Read and write from the same DB node</p> <p>Make sure that DB connection passed to Sherlock reads and writes to the same DB node so every lock change is visible to all of your services.</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>Add dependency to <code>build.gradle</code>: <pre><code>dependencies {\ncompile \"com.coditory.sherlock:sherlock-mongo-sync:0.4.19\"\n}\n</code></pre></p> <p>Create synchronous lock: <pre><code>// Get mongo locks collection\nMongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/sherlock\");\nMongoCollection&lt;Document&gt; collection = mongoClient\n.getDatabase(\"sherlock\")\n.getCollection(\"locks\");\n// Create sherlock\nSherlock sherlock = MongoSherlock.builder()\n.withLocksCollection(collection)\n.build();\n// Create a lock\nDistributedLock lock = sherlock.createLock(\"sample-lock\");\n</code></pre></p> <p>Acquire a lock: <pre><code>// Acquire a lock\nif (lock.acquire()) {\ntry {\nSystem.out.println(\"Lock granted!\");\n} finally {\nlock.release();\n}\n}\n</code></pre></p> <p>...or acquire a lock in a more concise way: <pre><code>lock.acquireAndExecute(() -&gt; {\nSystem.out.println(\"Lock granted!\");\n});\n</code></pre></p> <p>Learn more</p> <p>Learn how to use different APIs and connectors.</p>"},{"location":"about/","title":"About","text":"<ul> <li>GitHub Repository</li> <li>License</li> <li>Changelog</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#sherlock-installation","title":"Sherlock Installation","text":"<p>Different APIs and Connectors require different dependencies defined in <code>build.gradle</code>.</p> <p>Installing synchronous Sherlock with MongoDB Connector: <pre><code>dependencies {\nimplementation \"com.coditory.sherlock:sherlock-mongo-sync:0.4.19\"\n}\n</code></pre></p> <p>Installing reactive Sherlock with Reactor API and MongoDB Connector: <pre><code>dependencies {\nimplementation \"com.coditory.sherlock:sherlock-mongo-reactive:0.4.19\"\nimplementation \"com.coditory.sherlock:sherlock-api-reactor:0.4.19\"\n}\n</code></pre></p> <p>Installing reactive Sherlock with RxJava API and MongoDB Connector: <pre><code>dependencies {\nimplementation \"com.coditory.sherlock:sherlock-mongo-reactive:0.4.19\"\nimplementation \"com.coditory.sherlock:sherlock-api-rxjava:0.4.19\"\n}\n</code></pre></p> <p>Configuration looks similar for different connectors and can be generalized into: <pre><code>// synchronous\ndependencies {\nimplementation \"com.coditory.sherlock:sherlock-$CONNECTOR-sync:0.4.19\"\n}\n\n// reactor api\ndependencies {\nimplementation \"com.coditory.sherlock:sherlock-$CONNECTOR-reactive:0.4.19\"\nimplementation \"com.coditory.sherlock:sherlock-api-reactor:0.4.19\"\n}\n\n// rxjava api\ndependencies {\nimplementation \"com.coditory.sherlock:sherlock-$CONNECTOR-reactive:0.4.19\"\nimplementation \"com.coditory.sherlock:sherlock-api-rxjava:0.4.19\"\n}\n</code></pre></p>"},{"location":"locks/","title":"Locks","text":"<p>There are two main questions regarding lock acquisition:</p> <ul> <li>How long the lock should stay acquired? Lock Duration</li> <li>How to handle lock acquisition from the same instance? Lock Types</li> </ul>"},{"location":"locks/#lock-duration","title":"Lock Duration","text":"<p>Sherlock locks are acquired for a specific duration. Thanks to this approach when lock owning instance unexpectedly goes down, lock is automatically released after expiration.</p> <p>There are 3 methods to acquire a lock:</p> <ul> <li><code>lock.acquire()</code> - acquires lock for a default duration (5 minutes) after which lock is automatically released</li> <li><code>lock.acquire(Duration.ofMinutes(3))</code> - acquires a lock for a specific duration</li> <li><code>lock.acquireForever()</code> - acquires a lock forever. This lock never expires. Use it wisely.</li> </ul>"},{"location":"locks/#lock-types","title":"Lock Types","text":"<p>Sherlock provides different lock types to handle different locking scenarios:</p> <ul> <li>SingleEntrantDistributedLock - (default lock type) lock can be acquired only once. Even lock owner cannot acquire the lock for the second time.</li> <li>ReentrantDistributedLock - lock can be acquired by only one instance. Lock owner can acquire the lock for the second time.</li> <li>OverridingDistributedLock - lock state can be overridden freely. It's for administrative purposes.</li> </ul>"},{"location":"locks/#singleentrantdistributedlock","title":"SingleEntrantDistributedLock","text":"<p>Owner of a <code>SingleEntrantDistributedLock</code> cannot acquire the same lock twice. It's the default lock type.</p> <p>Acquiring lock with <code>SingleEntrantDistributedLock</code>:</p> <pre><code>DistributedLock lock = sherlock.createLock(lockId);\n\nInstance A                     | Instance B\nassert lock.acquire() == true; |\n| assert lock.lock() == false\nassert lock.acquire() == false;|\n</code></pre> <p>Releasing <code>SingleEntrantDistributedLock</code> (the same as <code>ReentrantDistributedLock</code>): <pre><code>Instance A                     | Instance B\nassert lock.acquire() == true; |\n| assert lock.lock() == false\n| assert lock.release() == false\nassert lock.release() == true; |\nassert lock.release() == false;|\n</code></pre></p>"},{"location":"locks/#reentrantdistributedlock","title":"ReentrantDistributedLock","text":"<p>Owner of a <code>ReentrantDistributedLock</code> can acquire the same lock multiple times</p> <p>Acquiring <code>ReentrantDistributedLock</code>: <pre><code>DistributedLock lock = sherlock.createReentrantLock(lockId);\n\nInstance A                     | Instance B\nassert lock.acquire() == true; |\n| assert lock.lock() == false\nassert lock.acquire() == true; |\n</code></pre></p> <p>Releasing <code>ReentrantDistributedLock</code> (the same as <code>SingleEntrantDistributedLock</code>): <pre><code>Instance A                     | Instance B\nassert lock.acquire() == true; |\n| assert lock.lock() == false\n| assert lock.release() == false\nassert lock.release() == true; |\nassert lock.release() == false;|\n</code></pre></p>"},{"location":"locks/#overridingdistributedlock","title":"OverridingDistributedLock","text":"<p><code>OverridingDistributedLock</code> lock may be acquired and/or released any time. It was created for purely administrative tasks, like releasing a lock that was blocked in acquired state. </p> <p>Acquiring a <code>OverridingDistributedLock</code> <pre><code>DistributedLock lock = sherlock.createOverridingLock(lockId);\n\nInstance A                     | Instance B\nassert lock.acquire() == true; |\n| assert lock.lock() == true\nassert lock.acquire() == true; |\nassert lock.acquire() == true; |\n</code></pre></p> <p>Releasing a <code>OverridingDistributedLock</code> <pre><code>Instance A                     | Instance B\nassert lock.acquire() == true; |\n| assert lock.lock() == true\n| assert lock.release() == true\nassert lock.release() == false;|\nassert lock.release() == false;|\n</code></pre></p>"},{"location":"migrator/","title":"Migrator","text":"<p>Incubating feature</p> <p>Sherlock migrator is an incubating feature. Its API may change. It is implemented only for synchronous connectors. </p>"},{"location":"migrator/#lock-based-migration-process","title":"Lock based migration process","text":"<p>Distributed locks may be used for multiple purposes one of them is a one way database migration process:</p> <pre><code>// prepare the migration\nSherlockMigrator migrator = new SherlockMigrator(\"db-migration\", sherlock)\n.addChangeSet(\"add db index\", () -&gt; /* ... */)\n.addChangeSet(\"remove stale collection\", () -&gt; /* ... */)\n\n// run the migration\nmigrator.migrate();\n</code></pre> <p>Migration rules:</p> <ul> <li>migrations must not be run in parallel (neither by one nor by multiple machines)</li> <li>migration change sets are applied in order</li> <li>migration change set must be run only once per all migrations</li> <li>migration process stops when first change set fails</li> </ul> <p>Migration mechanism is in experimental phase. It is available only in via sherlock-sync API.</p>"},{"location":"testing/","title":"Testing","text":"<p>Sherlock provides stubs and mocks for testing purposes. Try it out: <code>SherlockStub</code>, <code>ReactorSherlockStub</code>, <code>DistributedLockMock</code> and <code>ReactorDistributedLockMock</code>.</p> <p>Creating own stub and mocks</p> <p>Sherlock API consists mostly of interfaces, so it's easy to create stubs and mocks for your own purposes.</p> <p>Sample usage in spock tests:</p> <pre><code>def \"should release a lock after operation\"() {\ngiven: \"there is a released lock\"\nDistributedLockMock lock = DistributedLockMock.alwaysReleasedLock()\nwhen: \"single instance action is executed\"\nboolean taskPerformed = singleInstanceAction(lock)\nthen: \"the task was performed\"\ntaskPerformed == true\nand: \"lock was acquired and released\"\nlock.wasAcquiredAndReleased == true\n}\n\ndef \"should not perform single instance action when lock is locked\"() {\ngiven: \"there is a lock acquired by other instance\"\nDistributedLockMock lock = DistributedLockMock.alwaysAcquiredLock()\nwhen: \"single instance action is executed\"\nboolean taskPerformed = singleInstanceAction(lock)\nthen: \"action did not perform the task\"\ntaskPerformed == false\nand: \"action failed acquiring the lock\"\nlock.wasAcquireRejected == true\nand: \"action did not release the lock\"\nlock.wasReleaseInvoked == false\n}\n</code></pre> <p>In Memory Connector</p> <p>The easiest way to setup Sherlock in tests is to use In-Memory Connector. Use stubs when you need more control over the locking mechanism.</p>"},{"location":"api/","title":"Sherlock API","text":"<p>Sherlock exposes synchronous and reactive API in order to fit any code base. Exposed APIs:</p> <ul> <li>Synchronous API - Synchronous API that uses blocking database connectors</li> <li>Reactor API - Reactive API that uses Reactor and reactive database connectors</li> <li>RxJava API - Reactive API that uses RxJava (v2) and reactive database connectors</li> </ul>"},{"location":"api/reactor/","title":"Distributed Lock with Reactor API","text":"<p>Add dependencies to <code>build.gradle</code>:</p> <pre><code>dependencies {\ncompile \"com.coditory.sherlock:sherlock-mongo-reactive:0.4.19\"\ncompile \"com.coditory.sherlock:sherlock-api-reactor:0.4.19\"\n}\n</code></pre> <p>Create reactive lock with Reactor API: <pre><code>// Get mongo locks collection\nString database = \"sherlock\";\nMongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/\" + database);\nMongoCollection&lt;Document&gt; collection = mongoClient\n.getDatabase(database)\n.getCollection(\"locks\");\n// Create sherlock\nReactorSherlock sherlock = ReactiveMongoSherlock.builder()\n.withLocksCollection(collection)\n.buildWithApi(ReactorSherlock::reactorSherlock);\n// Create a lock with reactor api\nReactorDistributedLock lock = sherlock.createLock(\"sample-lock\");\n</code></pre></p> <p>Acquire a lock: <pre><code>// Acquire a lock\nlock.acquire()\n.filter(LockResult::isLocked)\n.flatMap(result -&gt; {\nSystem.out.println(\"Lock granted!\");\nreturn lock.release();\n})\n.block();\n</code></pre></p> <p>...or shorter <pre><code>lock.acquireAndExecute(() -&gt; Mono.just(\"Lock granted!\"))\n.block();\n</code></pre></p>"},{"location":"api/rxjava/","title":"Distributed Lock with RxJava API","text":"<p>Add dependencies to <code>build.gradle</code>:</p> <pre><code>dependencies {\ncompile \"com.coditory.sherlock:sherlock-mongo-reactive:0.4.19\"\ncompile \"com.coditory.sherlock:sherlock-api-rxjava:0.4.19\"\n}\n</code></pre> <p>Create reactive lock with RxJava API: <pre><code>// Get mongo locks collection\nString database = \"sherlock\";\nMongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/\" + database);\nMongoCollection&lt;Document&gt; collection = mongoClient\n.getDatabase(database)\n.getCollection(\"locks\");\n// Create sherlock\nRxSherlock sherlock = ReactiveMongoSherlock.builder()\n.withLocksCollection(collection)\n.buildWithApi(RxSherlock::rxSherlock);\n// Create a lock with reactor api\nRxDistributedLock lock = sherlock.createLock(\"sample-lock\");\n</code></pre></p> <p>Acquire a lock: <pre><code>// Acquire a lock\nlock.acquire()\n.filter(LockResult::isLocked)\n.flatMap(result -&gt; {\nSystem.out.println(\"Lock granted!\");\nreturn lock.release();\n})\n.blockingGet();\n</code></pre></p> <p>...or shorter <pre><code>lock.acquireAndExecute(Single.fromCallable(() -&gt; {\nlogger.info(\"Lock acquired!\");\nreturn true;\n})).blockingGet();\n</code></pre></p>"},{"location":"api/synchronous/","title":"Synchronous Distributed Lock","text":"<p>Add dependency to <code>build.gradle</code>:</p> <pre><code>dependencies {\ncompile \"com.coditory.sherlock:sherlock-mongo-sync:0.4.19\"\n}\n</code></pre> <p>Create synchronous lock: <pre><code>// Get mongo locks collection\nString database = \"sherlock\";\nMongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/\" + database);\nMongoCollection&lt;Document&gt; collection = mongoClient\n.getDatabase(\"sherlock\")\n.getCollection(\"locks\");\n// Create sherlock\nSherlock sherlock = MongoSherlock.builder()\n.withLocksCollection(collection)\n.build();\n// Create a lock\nDistributedLock lock = sherlock.createLock(\"sample-lock\");\n</code></pre></p> <p>Acquire a lock: <pre><code>// Acquire a lock\nif (lock.acquire()) {\ntry {\nSystem.out.println(\"Lock granted!\");\n} finally {\nlock.release();\n}\n}\n</code></pre></p> <p>...or acquire a lock in a more concise way: <pre><code>lock.acquireAndExecute(() -&gt; {\nSystem.out.println(\"Lock granted!\");\n});\n</code></pre></p>"},{"location":"connectors/","title":"Sherlock Connectors","text":"<p>Sherlock multiple database connectors to fit in your infrastructure. Provided connectors:</p> <ul> <li>Mongo Connector - Uses MongoDB and its JVM drivers to store locks</li> <li>SQL Connector - Uses SQL database (tested on Postgres and MySQL) and JDBC drivers to store locks</li> <li>In-Memory Connector - Stores locks in memory. Created for local development and testing.</li> </ul>"},{"location":"connectors/inmem/","title":"In Memory Distributed Lock","text":"<p>In Memory connector was created for local development and testing purposes.</p>"},{"location":"connectors/inmem/#synchronous-in-memory-sherlock","title":"Synchronous in-memory sherlock","text":"<p>Add dependency to <code>build.gradle</code>:</p> <pre><code>dependencies {\n    implementation \"com.coditory.sherlock:sherlock-inmem-sync:0.4.19\"\n}\n</code></pre> <p>Create in-memory sherlock: <pre><code>Sherlock sherlock = inMemorySherlockBuilder()\n.withClock(Clock.systemDefaultZone())\n.withUniqueOwnerId()\n.withSharedStorage()\n.build();\n// ...or simply\n// Sherlock sherlockWithDefaults = inMemorySherlock();\n</code></pre></p> <p>Learn more</p> <p>See the full synchronous example on Github, read sherlock builder javadoc.</p>"},{"location":"connectors/inmem/#reactive-in-memory-sherlock","title":"Reactive in-memory sherlock","text":"<p>Add dependencies to <code>build.gradle</code>:</p> <pre><code>dependencies {\n    implementation \"com.coditory.sherlock:sherlock-inmem-reactive:0.4.19\"\n    implementation \"com.coditory.sherlock:sherlock-api-reactor:0.4.19\"\n    // ...or use rxjava api\n    // implementation \"com.coditory.sherlock:sherlock-api-rxjava:0.4.12\"\n}\n</code></pre> <p>Create reactive in-memory sherlock: <pre><code>ReactorSherlock sherlock = reactiveInMemorySherlockBuilder()\n.withClock(Clock.systemDefaultZone())\n.withUniqueOwnerId()\n.withSharedStorage()\n.buildWithApi(ReactorSherlock::reactorSherlock);\n// ...or simply\n// ReactorSherlock sherlockWithDefaults = reactorSherlock(reactiveInMemorySherlock());\n</code></pre></p> <p>Learn more</p> <p>See the full reactive example on Github, read sherlock builder javadoc.</p> <p>RxJava version can be created in a similar way, see the sample on Github.</p>"},{"location":"connectors/mongo/","title":"Mongo Distributed Lock","text":"<p>MongoDB connector enables distributed locking on MongoDB. It was tested on MongoDB v3.4.</p> <p>Mongo Client</p> <p>There is no need for a special MongoClient configuration. Default settings, where all writes use master node, are sufficient. Sherlock uses no read queries and only the following modification operations: <code>findOneAndReplace</code>, <code>findOneAndDelete</code>, <code>deleteMany</code>.</p>"},{"location":"connectors/mongo/#synchronous-mongodb-sherlock","title":"Synchronous MongoDB Sherlock","text":"<p>Add dependency to <code>build.gradle</code>:</p> <pre><code>dependencies {\n    implementation \"com.coditory.sherlock:sherlock-mongo-sync:0.4.19\"\n}\n</code></pre> <p>Create synchronous mongo sherlock: <pre><code>String database = \"sherlock\";\nMongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/\" + database);\nMongoCollection&lt;Document&gt; locksCollection = mongoClient\n.getDatabase(database)\n.getCollection(\"locks\");\nSherlock sherlock = mongoSherlock()\n.withClock(Clock.systemDefaultZone())\n.withLockDuration(Duration.ofMinutes(5))\n.withUniqueOwnerId()\n.withLocksCollection(locksCollection)\n.build();\n// ...or simply\n// Sherlock sherlockWithDefaults = mongoSherlock(locksCollection);\n</code></pre></p> <p>Learn more</p> <p>See the full synchronous example on Github, read sherlock builder javadoc.</p>"},{"location":"connectors/mongo/#reactive-mongodb-sherlock","title":"Reactive MongoDB Sherlock","text":"<p>Add dependencies to <code>build.gradle</code>:</p> <pre><code>dependencies {\n    implementation \"com.coditory.sherlock:sherlock-mongo-reactive:0.4.19\"\n    implementation \"com.coditory.sherlock:sherlock-api-reactor:0.4.19\"\n    // ...or use rxjava api\n    // implementation \"com.coditory.sherlock:sherlock-api-rxjava:0.4.12\"\n}\n</code></pre> <p>Create reactive mongo sherlock: <pre><code>String database = \"sherlock\";\nMongoClient mongoClient = MongoClients.create(\"mongodb://localhost:27017/\" + database);\nMongoCollection&lt;Document&gt; locksCollection = mongoClient\n.getDatabase(database)\n.getCollection(\"locks\");\nReactorSherlock sherlock = reactiveInMemorySherlockBuilder()\n.withClock(Clock.systemDefaultZone())\n.withUniqueOwnerId()\n.withLocksCollection(locksCollection)\n.buildWithApi(ReactorSherlock::reactorSherlock);\n// ...or simply\n// ReactorSherlock sherlockWithDefaults = reactorSherlock(reactiveInMemorySherlock(locksCollection));\n</code></pre></p> <p>Learn more</p> <p>See the full reactive example on Github, read sherlock builder javadoc.</p> <p>RxJava can be created in a similar way, see the sample on Github.</p>"},{"location":"connectors/mongo/#locks-collection","title":"Locks collection","text":"<p>Sample lock document:</p> <pre><code>{\n\"_id\": \"lock-id\",\n\"acquiredBy\": \"owner-id\",\n\"acquiredAt\": { \"$date\": 1562502838189 },\n\"expiresAt\": { \"$date\": 1562503458189 }\n}\n</code></pre>"},{"location":"connectors/sql/","title":"SQL Distributed Lock","text":"<p>SQL connector enables distributed locking on a relational databases. It was tested on Postrgres v11 and MySQL v8.</p>"},{"location":"connectors/sql/#synchronous-sql-sherlock","title":"Synchronous SQL Sherlock","text":"<p>Add dependency to <code>build.gradle</code>:</p> <pre><code>dependencies {\nimplementation \"org.postgresql:postgresql:$versions.postgresql\"\n// ...or MySQL\n// implementation \"mysql:mysql-connector-java:8.0.27\"\n// ...or any other SQL driver\nimplementation \"com.zaxxer:HikariCP:$versions.hikaricp\"\n// ...or any other SQL Connection Pool\nimplementation \"com.coditory.sherlock:sherlock-sql:0.4.19\"\n}\n</code></pre> <p>Synchronous API only</p> <p>SQL connector provides synchronous API only.</p> <pre><code>HikariConfig config=new HikariConfig();\nconfig.setJdbcUrl(\"jdbc:postgresql://localhost:5432/test\");\nconfig.setUsername(\"postgres\");\nconfig.setPassword(\"postgres\");\nDataSource connectionPool=new HikariDataSource(config);\n\nSherlock sherlock=sqlSherlock()\n.withClock(Clock.systemDefaultZone())\n.withLockDuration(Duration.ofMinutes(5))\n.withUniqueOwnerId()\n.withConnectionPool(connectionPool)\n.withLocksTable(\"LOCKS\")\n.build();\n// ...or simply\n// Sherlock sherlockWithDefaults = sqlSherlock(connectionPool);\n</code></pre> <p>This example uses Hikari Connection Pool, but any implementation of <code>java.sql.DataSource</code> will suffice.</p> <p>Learn more</p> <p>See the full sample on Github, read sherlock builder javadoc.</p>"},{"location":"connectors/sql/#locks-table","title":"Locks Table","text":"<p>Locks table is automatically created if it did not already exist. Table is created with a following SQL:</p> <pre><code>CREATE TABLE LOCKS (\nID VARCHAR(100) NOT NULL,\nACQUIRED_BY VARCHAR(100) NOT NULL,\nACQUIRED_AT TIMESTAMP(3) NOT NULL,\nEXPIRES_AT TIMESTAMP(3),\nPRIMARY KEY (ID)\n)\n</code></pre> <p>Table name may be changed during sherlock creation.</p>"}]}